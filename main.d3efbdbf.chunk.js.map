{"version":3,"sources":["api/index.js","components/Feature.js","components/Loading.js","components/Preview.js","components/Search.js","components/Title.js","index.js"],"names":["BASE_URL","KEY","fetchQueryResultsFromURL","url","a","fetch","response","json","data","fetchQueryResults","century","classification","queryString","fetchAllCenturies","localStorage","getItem","JSON","parse","records","setItem","stringify","fetchAllClassifications","Feature","props","featuredResult","id","console","log","className","title","dated","culture","technique","images","src","baseimageurl","alt","Loading","Preview","setSearchResults","setFeaturedResult","setIsLoading","searchResults","info","fetchPage","pageUrl","results","error","disabled","prev","onClick","next","map","record","index","key","event","preventDefault","primaryurl","primaryimageurl","description","Search","useState","centuryList","setCenturyList","classificationList","setClassificationList","setQueryString","setCentury","setClassification","useEffect","Promise","all","then","values","catch","err","onSubmit","htmlFor","type","placeholder","value","onChange","target","length","name","item","Title","App","isLoading","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.d3efbdbf.chunk.js","sourcesContent":["/**\n * This file features and exports all of your calls to the API\n * \n * You need to replace YOUR_API_KEY in the string associated with KEY with your actual API key\n */\nexport const BASE_URL = 'https://api.harvardartmuseums.org';\nexport const KEY = 'apikey=370f3a7b-1abd-4303-b7d3-fb4fe4278240';\n\n/**\n * This will make a call to the API for a single term and value (e.g. \"person\", and \"unknown\"), and return the result\n */\nexport async function fetchQueryResultsFromTermAndValue(term, value) {\n  try {\n    const response = await fetch(`${ BASE_URL }/object?${ KEY }&${ term }=${ encodeURI(value.split('-').join('|')) }`);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This will make a call to the API for a preformed url (useful for previous and next buttons), and return the result\n */\nexport async function fetchQueryResultsFromURL(url) {\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * Requires an object { century: '', classification: '', queryString: '' } to be passed in as an argument\n * \n * Then makes a call to the API, and returns the first page of results\n */\nexport async function fetchQueryResults({\n  century,\n  classification,\n  queryString,\n}) {\n  const url = `${ BASE_URL }/object?${ KEY }&classification=${ classification }&century=${ \n    century }&keyword=${ queryString }`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are centuries stored in localStorage, or fetches them from the API and stores them in localStorage if not\n */\nexport async function fetchAllCenturies() {\n  if (localStorage.getItem('centuries')) {\n    return JSON.parse(localStorage.getItem('centuries'));\n  }\n\n  const url = `${ BASE_URL }/century?${ KEY }&size=100&sort=temporalorder`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('centuries', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are classifications stored in localStorage, or fetches them from the API and stores them in localStorage if not \n */\nexport async function fetchAllClassifications() {\n  if (localStorage.getItem('classifications')) {\n    return JSON.parse(localStorage.getItem('classifications'));\n  }\n\n  const url = `${ BASE_URL }/classification?${ KEY }&size=100&sort=name`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('classifications', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}","import React, { Fragment } from 'react';\nimport { render } from 'react-dom';\n\n// Don't touch this import\nimport { fetchQueryResultsFromTermAndValue } from '../api';\n\n/**\n * We need a new component called Searchable which:\n * \n * Has a template like this:\n * \n * <span className=\"content\">\n *  <a href=\"#\" onClick={async (event) => {}}>SOME SEARCH TERM</a>\n * </span>\n *\n * You'll need to read searchTerm, searchValue, setIsLoading, and setSearchResults off of the props.\n * \n * When someone clicks the anchor tag, you should:\n * \n * - preventDefault on the event\n * - call setIsLoading, set it to true\n * \n * Then start a try/catch/finally block:\n * \n * try:\n *  - await the result of fetchQueryResultsFromTermAndValue, passing in searchTerm and searchValue\n *  - send the result to setSearchResults (which will update the Preview component)\n * catch: \n *  - console.error the error\n * finally:\n *  - call setIsLoading, set it to false\n */\nconst Searchable = (props) => {\n    const {searchTerm, searchValue, setIsLoading, setSearchResults} = props\n    \n    return(\n        <span className='content'>\n            <a href='#' onClick={async (event) => {\n                event.preventDefault()\n                setIsLoading(true)\n                try{\n                    let results = await fetchQueryResultsFromTermAndValue(searchTerm, searchValue)\n                    setSearchResults(results)\n                }\n                catch(err){\n                    console.error(err)\n                }\n                finally{\n                    setIsLoading(false)\n                }\n                \n            }}>{searchTerm}</a>\n        </span>\n    )\n}\n\n/**\n * We need a new component called Feature which looks like this when no featuredResult is passed in as a prop:\n * \n * <main id=\"feature\"></main>\n * \n * And like this when one is:\n * \n * <main id=\"feature\">\n *   <div className=\"object-feature\">\n *     <header>\n *       <h3>OBJECT TITLE</h3>\n *       <h4>WHEN IT IS DATED</h4>\n *     </header>\n *     <section className=\"facts\">\n *       <span className=\"title\">FACT NAME</span>\n *       <span className=\"content\">FACT VALUE</span>\n *       <span className=\"title\">NEXT FACT NAME</span>\n *       <span className=\"content\">NEXT FACT VALUE</span>\n *     </section>\n *     <section className=\"photos\">\n *       <img src=IMAGE_URL alt=SOMETHING_WORTHWHILE />\n *     </section>\n *   </div>\n * </main>\n * \n * The different facts look like this: title, dated, images, primaryimageurl, description, culture, style, \n * technique, medium, dimensions, people, department, division, contact, creditline\n * \n * The <Searchable /> ones are: culture, technique, medium (first toLowerCase it), and person.displayname (one for each PEOPLE)\n * \n * NOTE: people and images are likely to be arrays, and will need to be mapped over if they exist\n * \n * This component should be exported as default.\n */\nconst Feature = (props) => {\n    const {featuredResult} = props\n    return(\n        <div>\n            {\n                (!featuredResult ? (<main id=\"feature\"></main>):(\n                    <main id=\"feature\">\n                        {console.log(featuredResult)}\n                      <div className=\"object-feature\">\n                        <header>\n                          <h3>{featuredResult.title}</h3>\n                          <h4>{featuredResult.dated}</h4>\n                        </header>\n                        <section className=\"facts\">\n                          <span className=\"title\">Culture</span>\n                          <span className=\"content\">{featuredResult.culture}</span>\n                          <span className=\"title\">Technique</span>\n                          <span className=\"content\">{featuredResult.technique}</span>\n                        </section>\n                        <section className=\"photos\">\n                          {featuredResult.images && featuredResult.images[0] ? <img src={featuredResult.images[0].baseimageurl} alt={featuredResult.title} /> : <img src='https://upload.wikimedia.org/wikipedia/commons/thumb/a/ac/No_image_available.svg/600px-No_image_available.svg.png' alt={featuredResult.title} /> }\n                        </section>\n                      </div>\n                    </main>\n                ))\n            } \n        </div>\n\n\n    )\n\n}\n\nexport default Feature;","import React from 'react';\n\nconst Loading = () => {\n\n    return (\n        <div id=\"loading\">\n            <h2 className=\"message\">Searching...</h2>\n        </div>\n    )\n    }\n\n    export default Loading;","import React from 'react';\n\n/**\n * We need to import fetchQueryResultsFromURL since we will sometimes have urls in info.prev and info.next\n * which are query urls.\n */\nimport { fetchQueryResultsFromURL } from '../api';\n\nconst Preview = (props) => {\n  const {setSearchResults, setFeaturedResult, setIsLoading }= props\n  const {info, records} = props.searchResults\n  /**\n   * Destructure setSearchResults, setFeaturedResult, and setIsLoading from props\n   * and also destructure info and records from props.searchResults\n   * \n   * You need info, records, setSearchResults, setFeaturedResult, and setIsLoading as available constants\n   */\n\n\n  /**\n   * Don't touch this function, it's good to go.\n   * \n   * It has to be defined inside the Preview component to have access to setIsLoading, setSearchResults, etc...\n   */\n  async function fetchPage(pageUrl) {\n    setIsLoading(true);\n\n    try {\n      const results = await fetchQueryResultsFromURL(pageUrl);\n      setSearchResults(results);\n    } catch (error) {\n      console.error(error);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  return <aside id=\"preview\">\n    <header className=\"pagination\">\n      {/* This button should be disabled if nothing is set in info.prev, and should call fetchPage with info.prev when clicked */}\n      <button \n        disabled={ !info.prev} \n        className=\"previous\"\n        onClick={()=>fetchPage(info.prev)}>Previous</button>\n      {/* This button should be disabled if nothing is set in info.next, and should call fetchPage with info.next when clicked */}\n      <button\n        disabled={ !info.next}\n        className=\"next\"\n        onClick={ ()=> fetchPage(info.next)}>Next</button>\n    </header>\n    <section className=\"results\">\n      {\n        records.map((record, index)=>{\n          return (\n            <div  \n            key={ index }\n            className=\"object-preview\"\n            onClick={(event) => {\n              event.preventDefault()\n              setFeaturedResult(record)\n              // set the featured result to be this record, using setFeaturedResult\n            }}>\n              {record.primaryurl ? (<img src={ record.primaryimageurl } alt={ record.description } />): null}\n              {record.title ? (<h3>{ record.title }</h3>): (<h3>MISSING INFO</h3>)}\n            </div>\n          )\n        })\n        /* Here we should map over the records, and render something like this for each one:\n          <div  \n            key={ index }\n            className=\"object-preview\"\n            onClick={(event) => {\n              // prevent the default\n              // set the featured result to be this record, using setFeaturedResult\n            }}>\n            { \n              // if the record.primaryimageurl exists, show this: <img src={ record.primaryimageurl } alt={ record.description } />, otherwise show nothing \n            }\n            {\n              // if the record.title exists, add this: <h3>{ record.title }</h3>, otherwise show this: <h3>MISSING INFO</h3>\n            }\n          </div>\n        */\n      }\n    </section>\n  </aside>\n}\n\nexport default Preview;","import React, { useEffect, useState } from 'react';\n\n/**\n * Don't touch these imports!\n */\nimport { \n  fetchAllCenturies,\n  fetchAllClassifications,\n  fetchQueryResults\n} from '../api';\n\nconst Search = (props) => {\n  const {setIsLoading, setSearchResults} = props\n  // Make sure to destructure setIsLoading and setSearchResults from the props\n\n\n  /**\n   * We are at the Search component, a child of app. This has a form, so we need to use useState for\n   * our controlled inputs:\n   * \n   * centuryList, setCenturyList (default should be an empty array, [])\n   * classificationList, setClassificationList (default should be an empty array, [])\n   * queryString, setQueryString (default should be an empty string, '')\n   * century, setCentury (default should be the string 'any')\n   * classification, setClassification (default should be the string 'any')\n   */\n   const [centuryList, setCenturyList] = useState([])\n   const [classificationList, setClassificationList] = useState([])\n   const [queryString, setQueryString] = useState('')\n   const [century, setCentury] = useState('any')\n   const [classification, setClassification] = useState('any')\n\n  /**\n   * Inside of useEffect, use Promise.all([]) with fetchAllCenturies and fetchAllClassifications\n   * \n   * In the .then() callback pass the returned lists to setCenturyList and setClassificationList\n   * \n   * Make sure to console.error on caught errors from the API methods.\n   */\n  useEffect(() => {\n    Promise.all([fetchAllCenturies(), fetchAllClassifications()]).then((values)=>{\n      console.log(\"YYYYYYY\", values)\n      setCenturyList(values[0])\n      setClassificationList(values[1])\n    }).catch((err)=>{\n      console.log(err)\n    })\n\n  }, []);\n\n  /**\n   * This is a form element, so we need to bind an onSubmit handler to it which:\n   * \n   * calls event.preventDefault()\n   * calls setIsLoading, set it to true\n   * \n   * then, in a try/catch/finally block:\n   * \n   * try to:\n   * - get the results from fetchQueryResults({ century, classification, queryString })\n   * - pass them to setSearchResults\n   * \n   * catch: error to console.error\n   * \n   * finally: call setIsLoading, set it to false\n   */\n  return <form id=\"search\" onSubmit={async (event) => {\n    event.preventDefault()\n    setIsLoading(true)\n    try{\n      const results = await fetchQueryResults({ century, classification, queryString })\n      console.log(\"hhhhhhh\",results)\n      setSearchResults(results)\n    }\n    catch(err){\n      console.log(err)\n    }\n    finally{\n      setIsLoading(false)\n    }\n    // write code here\n  }}>\n    <fieldset>\n      <label htmlFor=\"keywords\">Query</label>\n      <input \n        id=\"keywords\" \n        type=\"text\" \n        placeholder=\"enter keywords...\" \n        value={queryString} \n        onChange={(event)=>{setQueryString(event.target.value)}}/>\n    </fieldset>\n    <fieldset>\n      <label htmlFor=\"select-classification\">Classification <span className=\"classification-count\">({ classificationList.length })</span></label>\n      <select \n        name=\"classification\"\n        id=\"select-classification\"\n        value={classification} \n        onChange={(event)=>{setClassification(event.target.value)}}>\n        <option value=\"any\">Any</option>\n        {classificationList.map((item,index)=>{\n          return(<option key={index} >{item.name}</option>)\n        })\n        /* map over the classificationList, return an <option /> */}\n      </select>\n    </fieldset>\n    <fieldset>\n      <label htmlFor=\"select-century\">Century <span className=\"century-count\">({ centuryList.length })</span></label>\n      <select \n        name=\"century\" \n        id=\"select-century\"\n        value={century} \n        onChange={(event)=>setCentury(event.target.value)}>\n        <option value=\"any\">Any</option>\n        {centuryList.map((item, index)=>{\n          return(\n            <option key={index}>{item.name}</option>\n          )\n        })\n        /* map over the centuryList, return an <option /> */}\n      </select>\n     </fieldset>\n    <button>SEARCH</button>\n  </form>\n}\n\nexport default Search;","import React from 'react';\n\n\n //* Create/export a component called Title which uses this static HTML as the template:\n \n const Title = () => {\n\n    return(\n        <div id=\"title\">\n            <h1>\n                The Art Collector\n            </h1>\n            <h5>\n                Search the Harvard Art Museums' Private Collections\n            </h5>\n        </div>\n    )\n}\n\nexport default Title;\n","import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\n// These imports won't work until you fix ./components/index.js\nimport {\n Feature,\n  Loading,\n  Preview,\n  Search,\n  Title\n } from './components';\n\nconst App = () => {\n  /**\n   * We are at the App level component, which is top-most. Any state which needs to be shared between immediate children should\n   * be made here, so create state pairs using useState() for:\n   * \n   * searchResults, setSearchResults (default should be this object:  {info: {}, records: []} )\n   * featuredResult, setFeaturedResult (default should be null)\n   * isLoading, setIsLoading (default should be false)\n   */\n\n  const [searchResults, setSearchResults] = useState({info:{}, records:[]})\n  const [featuredResult, setFeaturedResult] = useState(null)\n  const [isLoading, setIsLoading] = useState(false)\n\n\n\n  return <div className=\"app\">\n    {/* <Title /> is static, doesn't need any props */}\n    <Title />\n    {/* <Search /> needs props for setIsLoading and setSearchResults (trigger <Loading /> on search start/end, and transfer results to preview) */}\n    <Search setIsLoading={setIsLoading} setSearchResults={setSearchResults}   />\n    {/* <Preview /> needs props for searchResults, setIsLoading and setSearchResults (clicking prev/next buttons), and setFeaturedResult (clicking a preview) */}\n    <Preview searchResults={searchResults} setIsLoading={setIsLoading} setSearchResults={setSearchResults} setFeaturedResult={setFeaturedResult}  />\n    {/* <Feature /> needs props for featuredResult, as well as setIsLoading and setSearchResults (clicking on searchable properties) */}\n    <Feature featuredResult={featuredResult} setIsLoading={setIsLoading} setSearchResults={setSearchResults} />\n    {/* <Loading /> is static, but should only render when isLoading is true */}\n    {isLoading ? (<Loading />):null}}\n  </div>\n}\n\n/**\n * Boostrap the <App /> component into the '#app' element in the DOM,\n * using ReactDOM.render();\n */\n ReactDOM.render(<App />, document.getElementById('app'))"],"sourceRoot":""}